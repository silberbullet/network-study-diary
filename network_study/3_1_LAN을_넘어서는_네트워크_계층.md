# 3-1 LAN을 넘어서는 네트워크 계층

스터디 일자 : 2024.9.03 (화) 20:00

[스터디 끝난 회고](#-스터디-끝난-회고)

## 📚 공부 정리

### 📌 데이터 링크 계층의 한계

**❗ 물리 계층과 데이터 링크 계층만으로 미국에 있는 친구에게 메시지를 보내기 어렵다.**
  - 물리 계층과 데이터 링크 계층만으로는 다른 네트워크까지의 도달 경로를 파악하기 어려움.
    - 두 개의 계층은 LAN을 다루는 계층
    - 미국 까지 가는데 다양한 경로를 통해 이동을 해야하지만 **라우팅** 기능이 존재하지 않음.
      - `라우팅`은 패킷이 이동할 최적의 경로를 결정해줌. (라우터)
      - 네트워크 계층이 있어야 네트워크 간의 라우팅이 가능.
        
**❗ MAC 주소만으로는 모든 네트워크에 속한 호스트의 위치를 특정하기 어렵다.**
  - MAC은 택배로 비교할 때, 송신인과 같음.
  - 송신인 가지고는 택배를 보내기 어려움.

### 📌 인터넷 프로토콜(IP)

**❗ 네트워크 계층의 IP**
  - MAC 주소가 수신인 역할을 한다면, 수신지 역할은 **네트워크 계층의 IP주소**
  - IP 주소는 `논리 주소`라고 함.
  - DHCP 프로토콜을 이용해 자동으로 할당 받거나 사용자가 지적 할당 혹은 복수의 IP 주소를 가질 수 있음.
  - IP 주소를 기반으로 라우팅이 일어남.

**❗ IP 주소 형태**
  - 4byte로 주소 표현, 숫자당 8비트로 표현되어 0~255범위 안에 있는 네 개의 10진수로 표현
  - 8비트를 `옥텟`이라고 불림
  - 192.168.1.1 각 숫자들은 8비트로 표현 옥텟

**❗ IP 기능**
  - **IP 주소 지정**
    - IP 주소를 바탕으로 송수신 대상을 지정함
       
  - **IP 단편화**
    - 전송하고자 하는 패킷의 크기가 MTU라는 최대 전송 단위보다 클 경우, 이를 MTU 크기 이하의 복수의 패킷을 나누는 것
      - **MTU** : 한 번에 전송 가능한 IP 패킷의 최대 크기 ( 일반적으로 1500BYTE )
        - https://en.wikipedia.org/wiki/Maximum_transmission_unit#Table_of_MTUs_of_common_media
        - https://www.hardreset.info/ko/articles/speed-up-wifi/
          ```
          MTU는 간단히 말하자면 하나의 프레임(or 패킷)으로 보낼 수 있는 최대 데이터 크기라고 보시면 됩니다.
            MTU보다 큰 프레임은 여러 개의 프레임으로 쪼개져서 전송되게 됩니다.
            MTU 1500이 흔히 말하는 이더넷(v2)의 표준 MTU 값이며, 이보다 큰 값 (1501~9216)을 점보 프레임이라고 부릅니다.
            MTU가 크면 한번에 보낼 수 있는 데이터량이 많아지게 되므로 효율이 증가합니다. (일반적으로 인터럽트 부하가 줄어들거나 최대 네트워크 대역폭이 증가하는 형태로 보여지게 됩니다.) 반면, 작은 크기의 프레임이 빈번한 요청을 하는 경우이거나 네트워크 대역폭/품질이 나쁜 경우에는 오히려 네트워크 성능이 떨어지게 됩니다.
            
            1500으로 꽁꽁 묶여있는 까닭은 동일한 매체에 MTU가 서로 다른 장비들이 연결될 경우 혼선이 발생하기 때문입니다. 만약 점보 프레임 (보편적으로 MTU 9000이 주로 쓰입니다.)을 사용한다면, 그 매체에 연결된 모든 장치는 동일한 MTU 값을 사용하여야만 네트워크에 혼선이 없습니다.
            
            TCP에도 MTU라는 개념은 존재합니다만, 이쪽은 Path MTU discovery 알고리즘을 사용하여 호스트간의 MTU값을 결정하기 때문에 표준 규격에서는 최소값만 존재합니다. (상호간의 MTU 값이 다를 경우 작은 쪽에 맞춥니다.)
            
            일반적으로 이더넷 망의 MTU 크기를 건들이는 것 자체가 호환성 문제를 일으킬 수 있기 때문에 크기를 조절하는 것은 추천하지 않습니다. (컴퓨터들의 성능이 좋아진 지금은 1Gbps의 경우도 MTU 9000을 굳이 사용할 필요성이 적습니다. 10Gbps정도 되면 필요해지긴 합니다.)
            또한, 공인망(인터넷)에 연결된 NIC의 경우 점보 프레임을 사용하는 것은 그리 추천하고 싶지 않습니다. 공인망의 경우 점보 프레임을 사용할 정도의 대역폭을 제공하는 경우가 흔치 않고, 작은 프레임이 빈번한 상황에서 네트워크 속도 지연이 발생할 수 있으니까요
          ```
**❗ IPv4**

IPv4 패킷은 프레임의 페이로드로 데이터 필드 명시 된다.

**IPv4의 중요한 7가지 헤더**
  - **식별자**
    - 패킷에 할당된 번호
    - 메시지 전송 과정에서 IPv4 패킷이 여러 조각으로 쪼개져서 전송되었을 때, 수신지에서 이를 재조합하기 위해 사용.
      
  - **플래그**
    - IP 단편화 수행 여부를 나타내는 세 개의 비트
    - 첫 번째 비트는 항상 0으로 예약되어 있으며 현재 사용되지 않음
    - 나머지 두 개의 비트 중에서 하나는 **DF(Don’t Fragment)** 라고 불리며, IP 단편화의 수행 여부를 나타냄.
    - 또 다른 비트는 **MF(More Fragment)** 라고 불리며, 단편화된 패킷이 더 있는지를 확인하는 플래그.
      
  - **단편화 오프셋**
    - 패킷이 단편화되기 전, 패킷의 초기 데이터에서 몇 번째로 떨어진 패킷인지 나타냄
    - 패킷은 순서대로 도달하지 않을 수 있기 때문에, 수신지에서 재조합 시, 이를 판단하기 위해 사용.
      
  - **프로토콜**
    - 위 계층의 프로토콜이 무엇인지 나타냄.
    - TCP는 6번, UDP는 17번.

  - **송신지 IP주소와 수신지 IP주소**
      - 이름 그대로, 송수신지의 IPv4 주소

  - **TTL(Time To Live)**
      - 패킷의 수명
      - 외부 네트워크와 통신 시, 여러 라우터를 거치는데, 라우터 하나를 통과할 때 마다 TTL이 1씩 감소하며, TTL 값이 0으로 떨어진 패킷은 폐기.
      - 패킷이 호스트 또는 라우터에 한 번 전달되는 것을 **홉(hop)**이라고 하며, TTL 필드의 값은 홉마다 1씩 감소.
      - 이를 통해, 잔류되는 무의미한 패킷을 방지할 수 있음.
      - TTL 필드가 0이 되면, 해당 패킷은 폐기 되고, 패킷을 송신한 호스트에게 시간 초과(Time Exceeded) 메시지가 전송되며 이를 알려주는 프로토콜을 **ICMP**라고 함
        
  - **HELEN(Header Length)**
      - 헤더 길이(Header Length)를 줄여 HELEN이라고 함.
        
  - **서비스 유형(Service Type)**
      - 패킷의 전송 방식을 결정하는 데 사용되며, 네트워크에서 패킷 처리에 우선 순위를 지정하거나 다양한 서비스 품질(QoS)을 설정하기 위해 활용
      - ChatGPT
          - **우선 순위 (Precedence, 3비트):**
              - 우선 순위는 0에서 7까지의 값으로, 패킷의 우선 순위를 나타냄. 7이 가장 높은 우선 순위이며, 0이 가장 낮은 우선 순위.
              - 예를 들어, 우선 순위가 높은 패킷은 네트워크 혼잡 시에도 먼저 전송될 가능성이 큼.
          - **TOS (Type of Service, 4비트):**
              - TOS 필드는 패킷이 네트워크에서 어떤 식으로 처리되기를 원하는지를 나타내는 값입니다. TOS 필드는 각 비트가 특정 기능을 나타냄
                  - **최소 지연 (Minimize Delay, D)**: 이 비트가 설정되면, 지연이 적은 경로를 통해 패킷이 전송되기를 원한다는 의미입니다. 보통 실시간 애플리케이션(예: 음성 또는 비디오 스트리밍)에 사용.
                  - **최대 처리량 (Maximize Throughput, T)**: 이 비트가 설정되면, 처리량이 높은 경로를 통해 패킷이 전송되기를 원한다는 의미입니다. 파일 전송 등 큰 데이터를 빠르게 전송하는데 유리.
                  - **최소 신뢰성 (Minimize Reliability, R)**: 이 비트가 설정되면, 신뢰성이 높은 경로를 통해 패킷이 전송되기를 원한다는 의미입니다. 중요 데이터 전송 시 사용.
                  - **최소 비용 (Minimize Cost, C)**: 이 비트가 설정되면, 전송 비용이 적게 드는 경로를 통해 패킷이 전송되기를 원한다는 의미.
          - 미사용 비트 (Unused, 1비트):
              - 이 비트는 사용되지 않으며 항상 0으로 설정되어 있음.

  - **헤더 체크섬(Header Checksum)**
      - 헤더에 오류가 있는지 확인하는 데 사용.
      - IP 헤더는 체크섬 값과 비교되어, 헤더 체크섬이 일치하지 않으면 패킷이 삭제.
    
**❗ IPv6**

IPv6 패킷의 기본 헤더는 IPv4에 비해 간소화되어 있음

IPv4 헤더 길이는 가변적이지만, IPv6 기본 헤더는 40바이트로 고정적.

아직까진 IPv4가 많이 사용되지만, IPv6 또한 다수의 장비에서 지원.
  
  - **다음 헤더**
    - 상위 계층의 프로토콜을 가리키거나 확장 헤더를 가리킴.
    - IPv6는 위의 그림에서 보는 **기본 헤더** 외에 추가적인 **확장 헤더(Extension Header)**를 가질 수 있음.
    - 아래의 그림처럼 **확장 헤더는 기본 헤더와 페이로드의 사이에 위치**
      
  - **홉 제한**
    - IPv4 패킷의 TTL 필드와 비슷하게 패킷의 수명을 나타냄.
      
  - **송신지 IP주소와 수신지 IP주소**
    - IPv6 주소 지정 필드
   
**❗IPv6의 단편화**

IPv6는 IPv4와 달리 단편화 관련 필드가 없고, 단편화 확장 헤더(Fragment Extension Header)를 통해 단편화가 이루어짐.

  - 단편화 확장 헤더에도 다음 헤더(Next Header) 필드가 있으며, 이를 통해 또 다른 확장 헤더 혹은 상위 프로토콜을 가리키기 위함.
  - 예약됨(reserved)와 예약(res)필드는 `0`으로 고정되어 사용되지 않음.
  - 단편화 오프셋과 M 플래그, 식별자 필드는 각각 IPv4의 단편화 오프셋, MF 플래그, 식별자 필드와 같은 역할을 수행.
      - 단편화 오프셋: 현재 단편화된 패킷의 위치
      - M 플래그: `1`일 경우 더 많은 단편화 패킷이 있음, `0`일 경우 마지막 패킷임
      - 식별자: 동일한 메시지에서부터 단편화된 패킷임을 식별하기 위해 사용된다.

### 📌 ARP
MAC주소와 IP 주소는 함께 사용되지만, 기본적으로 IP 주소를 우선적을 고려.

즉, **상대 호스트의 IP 주소는 알지만, MAC 주소는 알지 못하는 상황**이 생겼을 때, ARP 프로토콜을 사용한다.

동일 네트워크 내에 있는 송수신 대상의 IP주소를 통해 MAC 주소를 알아낸다.

**❗ ARP 동작 과정**

  -**ARP 요청(ARP Request)**
    - A는 네트워크 내의 모든 호스트에게 브로드캐스트 송신하고자 하는 IP 주소와 함께 메시지를 보낸다.
      - 브로드캐스트: 자신을 제외한 네트워크 상의 모든 호스트에게 요청

  -**ARP 응답(ARP Reply)**
    - 네트워크 내의 모든 호스트가 ARP 요청 메시지를 수신하지만, 해당 IP가 아닌 호스트는 이를 무시하며, 해당 IP의 호스트는 자신의 MAC 주소를 요청 호스트에게 유니캐스트 방식으로 메시지를 전송.

**❗ ARP 테이블 갱신**

  - ARP를 활용할 수 있는 모든 호스트는 ARP 테이블이라는 정보를 유지한다.
      - IP 주소와 그에 맞는 MAC 주소를 대응하는 표
  - A는 ARP 요청, 응답을 통해 MAC 주소를 알게 되면 다음의 표처럼 IP 주소에 대응되는 MAC 주소를 추가함.

| IP 주소 | MAC 주소 |
| --- | --- |
| 10.0.0.2 | A1:B2:C3:D4:E5:F6 |
|  |  |

  - 이렇게하면, 이제 ARP 요청을 최초의 한 번만 수행하고, 이후는 테이블만 확인하면 통신하고자하는 IP 주소를 가진 호스트의 MAC 주소를 언제든지 확인 가능.
  - ARP 테이블은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수 있음. (MAC 주소 테이블과 비슷?)
  - 윈도우 혹은 맥OS에서 `arp -a` 라고 입력하면 다음과 같이 IP주소에 대응된 MAC주소를 볼 수 있다.

**❗ ARP 패킷**

ARP 패킷은 데이터 링크 계층의 PDU인 프레임의 페이로드에 포함되어 전송된다.

  - **ARP 패킷의 주요 필드**
    - 오퍼레이션 코드(Operation Code)
        - ARP 패킷의 유형을 나타냄,
            - ARP 요청: `1`
            - ARP 응답: `2`
    - 송신지, 수신지 하드웨어 주소(Sender, Target Hardware Address)
        - 송신지와 수신지의 MAC 주소가 명시
        - ARP 요청 시, 이더넷 프레임의 수신지 MAC 주소에는 브로드캐스트 메시지임을 나타내는 `ff:ff:ff:ff:ff:ff` 가 명시되며, ARP 패킷의 수신지 하드웨어 주소에는 `00:00:00:00:00:00` 가 명시.
    - 송신지, 수신지 프로토콜 주소(Sender, Target Protocal Address)
        - 송신지, 수신지의 IP 주소가 명시

## 서로 다른 네트워크에 속해 있는 경우

- 서로 다른 네트워크에 속해 있는 호스트와의 통신 또한 ARP 프로토콜을 사용하나, 네트워크 외부로 나가기 위한 장비(라우터)의 MAC 주소를 알아내서 전송하는 것이 차이점임.
- 즉, 호스트는 다른 네트워크 상의 호스트끼리의 MAC 주소는 알지 못하고, Router에 저장된 ARP 테이블의 MAC 주소를 확인해 통신.
- 실제로 라우터 간 통신을 주고 받을 때는 ARP만 사용하지는 않음.

### 📌 IP 단편화를 피하는 방법
  - IP 단편화는 되도록 하지 않는 것이 좋음.
      -  데이터가 여러 패킷으로 쪼개지면, 자연스레 전송해야할 패킷의 헤더들도 많아지고, 이는 불필요한 트래픽 증가와 대역폭 낭비로 이어짐
  - IP 패킷을 주고 받는 모든 호스트의 ‘처리 가능한 MTU 크기’를 고려가 필요함.
      - 즉, IP 단편화 없이 주고 받을 수 있는 최대 크기만을 전송. 이 크기를 **경로** **MTU(Path MTU)**라고 함.
  - 경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 회피하는 기술을 **경로** **MTU 발견(Path MTU Discovery)**. (오늘날 네트워크는 대부분 이 기술을 지원)
  - 와이어샤크라는 프로그램을 통해 실제 IP 패킷을 확인해보면 대부분의 IP 패킷에 DF 플래그(IP 단편화를 수행하지 말라)가 설정되어 있음.
  - 만약 DF 플래그가 설정되어 있는데, MTU를 초과한 데이터를 전송한다면, ‘단편화 없이 처리할 수 없습니다.'라는 메시지를 받게 되며, 호스트는 이 오류 메시지를 받지 않을 때까지, 데이터 크기를 점차 줄임.


## ⭐ 스터디 끝난 회고

네트워크와 서버는 눈으로 보기가 힘듭니다. 책으로 탐구하기에 힘든 영역이 네트워크 계층인 것 같습니다. 정용님 발표 중 ‘**ARP이 IP를 통해 호스트의 MAC 주소를 알아내는 과정**’에서 추상적으로 접근한 방식이 좋았습니다. 이해하기 힘든 객체는 비유를 통해 이해하는 과정도 좋은 학습 방법이라 생각이 듭니다. 덕분에 ARP 프로토콜의 전처리 과정이 쉽게 이해됐습니다. 비유를 통한 학습 방법도 와닿지 않는 분야를 이해하는데 큰 도움이 된다는 걸 깨달았습니다.
    
IPv4에 생각보다 덧붙여지는 헤더들이 많았습니다. 헤더가 길어지면 통신 시 긴 헤더를 읽느라 전송에 우려가 있어 보였습니다. 그래서 IPv6 헤더의 길이를 40바이트로 고정한게 이해가 갔습니다. 
    
**추가 여담으로 서블릿 혹은 자바에서도 HTTP 통신 시 헤더가 너무 길면 에러를 유발하기도 합니다. ex) `java.net.ProtocolException: HTTP header too long`,  서블릿 환경에서의 `Request Header Too Large`**
